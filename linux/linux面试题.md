**1.CPU负载和CPU利用率的区别是什么？**

可以通过uptime,w或者top命令看大CPU的平均负载

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhvwRIlJd8pSfSb6AAxw1kUhFPJ8KibRia4KxkHWHwBQvTOkhtib39Kxfvg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhDY6yINBYhEycwlZWr8XxGqhiaS5mozVMVZ3yq42H2dAyZWgQXxkFUqg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**Load Average(负载)**:负载的3个数字，比如上图的4.86,5.8,5.00,分别代表系统在过去的1分钟，5分钟，15分钟内的系统平均负载。他代表的是当前系统**正在运行和和处于等待运行的进程数之和**。也指的是处于**可运行状态和不可中断状态的平均进程数**

如果单核CPU的话，负载达到1就代表CPU已经达到满负荷的状态了，超过1，后面的进行就需要排队等待处理了。

如果是是多核多CPU的话，假设现在服务器是2个CPU，每个CPU2个核，那么总负载不超过4都没什么问题。

### 怎么查看CPU有多少核呢？

通过下一命令查看CPU情况

```shell
cat /proc/cpuinfo | grep "model name" 
```

通过 查看CPU的核数

```shell
cat /proc/cpuinfo | grep "cpu cores"
```



**CPU利用率**:和负载不同，CPU利用率指的是当前**正在运行**的进程实时占用CPU的百分比，他是对一段时间内CPU使用状况的统计。

我举个栗子🌰：

假设你们公司厕所有1个坑位，有一个人占了坑位，这时候负载就是1，如果还有一个人在排队，那么负载就是2。

如果在1个小时内，A上厕所花了10分钟，B上厕所花了20分钟，剩下30分钟厕所都没人使用，那么这一个小时内利用率就是50%。

简而言之：

负载就是**正在运行和等待的进程数之和**

利用率是**正在运行**的进程

### 2.那如果CPU负载很高，利用率却很低该怎么办？



CPU**负载很高，利用率却很低，说明处于等待状态的任务很多**，负载很高，代表可能很多僵死的进程。通常这种情况时IO密集型的任务，大量请求在请求相同的IO，导致任务队列堆积。

同样，可以先通过`top`命令观察(截图只是示意，不代表真实情况)，假设发现现在确实是高负载低使用率。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhZtqWKVS8iad2rYo1Yj3BZ1pksWpkgdpicYms24qDnBLXFzJeOPFRJiciag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

然后，在通过命令 `ps -axjf`查看为 D+状态的进程，这个状态指的就是不可中断的睡眠状态的进程。处于这个状态的进程无法终止，也无法自行退出，只能通过恢复其依赖的资源或者重启系统来解决

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhIM5P9GSeFqQ3cIgDiaNNPMpbMU5wJXZBw4fiaaT7CGSpDK1ntx9OUXfg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### 3.那如果负载很低，利用率却很高呢？

这表示CPU的任务并不多，但是任务执行的时间很长，大**概率就是你写的代码本身有问题，通常是计算密集型任务，生成了大量耗时短的计算任务。**

怎么排查？直接`top`命令找到使用率最高的任务，定位到去看看就行了。如果代码没有问题，那么过段时间CPU使用率就会下降的。

### 4.那如果CPU使用率达到100%呢？怎么排查？

1.通过top找到占用率高的进程

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhuRsibVXxW9SRfyqpQ3BibwBQPtgsCBfDAaeXdYcVeQTUjuYYIocdqMeA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2.通过 top -Hp pid 找到占用CPU高的线程ID，这里找到958的线程ID

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhRs9ZKX1UAuuABVHeqWiaMJsDOUjGIjUyHnJAbLEicWgD4iaWQYaibklbag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



3.再把线程ID转化为16进制，`printf "0x%x\n" 958`，得到线程ID`0x3be`

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhKOCk3psjNH4lOMxJwKmP5033B8icpshzkQvdzDottaVh28kcZ6zJlxw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

4.通过命令`jstack 163 | grep '0x3be' -C5 --color` 或者 `jstack 163|vim +/0x3be -` 找到有问题的代码

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhgPK9rmZ5npLAtgmIia4TLjFdGVrSXAAZeMn3m5RE8tKMLn9WBnU9CZw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 5.说说常见的Linux命令吧？

**常用的文件、目录命令**

`ls`：用户查看目录下的文件，`ls -a`可以用来查看隐藏文件，`ls -l`可以用于查看文件的详细信息，包括权限、大小、所有者等信息。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhibXXocCSBqic77sdcSXB4oSdjk0K5V5zh5Nj1YnBlj988yNV26hasoLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

`touch`：用于创建文件。如果文件不存在，则创建一个新的文件，如果文件已存在，则会修改文件的时间戳。

`cat`：cat是英文`concatenate`的缩写，用于查看文件内容。使用`cat`查看文件的话，不管文件的内容有多少，都会一次性显示，所以他不适合查看太大的文件。

`more`：more和cat有点区别，more用于分屏显示文件内容。可以用`空格键`向下翻页，`b`键向上翻页

`less`：和more类似，less用于分行显示

`tail`：可能是平时用的最多的命令了，查看日志文件基本靠他了。一般用户`tail -fn 100 xx.log`查看最后的100行内容

**常用的压缩命令**

`zip`：压缩zip文件命令，比如`zip test.zip 文件`可以把文件压缩成zip文件，如果压缩目录的话则需添加`-r`选项。

`unzip`：与zip对应，解压zip文件命令。`unzip xxx.zip`直接解压，还可以通过`-d`选项指定解压目录。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmvPFvQ3yVL1tQYGibHicYClhsKzJfgEjPsW1zqnntxd55JrD6CiaiatfB6cuwZHNAdZvict4ghPRD2vLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
gzip`：用于压缩.gz后缀文件，gzip命令不能打包目录。需要注意的是直接使用`gzip 文件名`源文件会消失，如果要保留源文件，可以使用`gzip -c 文件名 > xx.gz`，解压缩直接使用`gzip -d xx.gz
```

`tar`：tar常用几个选项，`-x`解打包，`-c`打包，`-f`指定压缩包文件名，`-v`显示打包文件过程，一般常用`tar -cvf xx.tar 文件`来打包，解压则使用`tar -xvf xx.tar`。

Linux的打包和压缩是分开的操作，如果要打包并且压缩的话，按照前面的做法必须先用tar打包，然后再用gzip压缩。当然，还有更好的做法就是`-z`命令，打包并且压缩。

使用命令`tar -zcvf xx.tar.gz 文件`来打包压缩，使用命令`tar -zxvf xx.tar.gz`来解压缩





## Linux进程

说到进程，恐怕面试中最常见的问题就是线程和进程的关系了，那么先说一下答案：**在 Linux 系统中，进程和线程几乎没有区别**。

一、进程是什么？

![image-20210822155916551](D:\Typora图片\image-20210822155916551.png)

那么，操作系统是如何创建进程的呢？**对于操作系统，进程就是一个数据结构**，我们直接来看 Linux 的源码：

```c
struct task_struct{
    //进程状态
    long state;
    //虚拟内存结构体
    struct mm_struct *mm;
    //进程号 
    pid_t pid;
    //指向父进程的指针
    struct task_struc __rcu *parent;
    //子进程列表
    struct list_head children;
    //存放文件系统信息的指针
    struct fs_struct        *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct        *files;
}
```

`task_struct`是 Linux内核对于一个进程的描述，也可以称为**进程描述符**。源码比较复杂，我这里就截取了一小部分比较常见的。

其中比较有意思的是`mm` 指针和 `files` 指针。`mm` 指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；`files` 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。



## 二、文件描述符是什么

先说`files`,它是一个**文件指针数组**。一般来说，一个进程会从`files[0]`读取**输入**，将**输出**写入`files[1]`,将**错误信息**写入`files[2]`。

**每个进程被创建时，`files` 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引**，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。



![image-20210824172513506](D:\Typora图片\image-20210824172513506.png)



对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过「系统调用」让内核进程访问硬件资源。

PS：不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。



如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到`files`的第四个位置：

![image-20210824172911776](D:\Typora图片\image-20210824172911776.png)

明白了这个原理，

**输入重定向**就很好理解了，程序想读取数据的时候就会去 `files[0]` 读取，所以我们只要把 `files[0]` 指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：

```shell
$ command < file.txt
```

![image-20210824173010889](D:\Typora图片\image-20210824173010889.png)



同理，**输出重定向**就是把 `files[1]` 指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：

```shell
$ command > file.txt
```

![image-20210824173119963](D:\Typora图片\image-20210824173119963.png)

**管道符**其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：



```shell
$ cmd1 | cmd2 | cmd3
```





![image-20210824173316249](D:\Typora图片\image-20210824173316249.png)

到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的 `files` 数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。



## 三、线程是什么 线程和父进程共享数据区域 而子进程会拷贝一份页表开辟一块新的内存和文件描述数组

首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。

为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。

我们知道系统调用 `fork()` 可以新建一个子进程，函数 `pthread()` 可以新建一个线程。**但无论线程还是进程，都是用** **`task_struct`** **结构表示的，唯一的区别就是共享的数据区域不同**。



换句话说，线程看起来根进程没有区别，**只是线程的某些数据区域和其父进程是共享的**，而子进程是拷贝副本，而不是共享。就比如说，`mm`结构（虚拟内存）和`files`结构（文件描述符）在线程中都是**共享**的，我画两张图 你就明白了：

子进程与父进程的关系：

![image-20210824174630923](D:\Typora图片\image-20210824174630923.png)

线程与其父进程的关系：

![image-20210824174736033](D:\Typora图片\image-20210824174736033.png)

所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。

那么你可能问，**既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢**？

因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。



当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。



在 Linux **中新建线程和进程的效率都是很高的**，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。**所以 Linux 中新建进程和新建线程都是很迅速的**。



CopyOnWrite容器

通俗地讲，当我们往容器中添加一个元素的时候，不是直接添加，而是对当前容器copy，复制一个容器，在这个容器的复制中添加元素，添加完之后，再将引用指向这个新容器



CopyOnWrite机制的优缺点

优点：

CopyOnWriteArrayList保证了数据在**多线程操作时的最终一致性**。



缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；

刚才说了，CopyOnWriteArrayList只能保证最终的数据一致性，而不能保证实时的数据一致性。这一点也是我们在使用的过程中，必须要考虑到的因素。

仔细思考下，其实CopyOnWrite容器也是一种读写分离，读和写是不同的容器。





### Linux fork()的写时拷贝COW 

Linux在使用fork()函数进程创建时，传统fork()的做法是系统把所有的资源复制给新创建的进程，这种方式不仅单一，而且效率低下。因为**所拷贝的数据或别的资源可能是可以共享的**。

现在的Linux的fork()使用写时拷贝页来实现新进程的创建，它是一种可推迟甚至避免数据拷贝的技术，刚开始时内核并不会复制整个地址空间，而是让父子进程共享地址空间，只有在写时才复制值空间，使得父子进程都拥有独立的地址空间，即**资源的复制是在只有写时才会发生**，因此称之为Copy on Write（COW）。在此之前都是以读的方式去和父进程共享资源，这样，在页根本不会被写入的场景下，**fork()立即执行exec()**，无需对地址空间进行复制，**fork()的实际开销**就是复制父进程的一个**页表**和为**子进程创建一个进程描述符**，也就是说只有当前进程空间中各段内存内容发生变化时，父进程才将其内容复制一份给子进程，大大提高了效率。



那么子进程的物理空间没有代码，怎么去取指令执行exec系统调用呢？

其实，在fork()之后，exec()之前，子进程和父进程是共享物理空间（内存区）的，子进程的代码段，数据段和堆栈都指向父进程物理空间，即**两者的虚拟空间不同，但物理空间其实是同一个**

当父进程或者子进程有需要修改段的行为时，再为子进程分配相应段的物理空间，

若不是exec，则内核会给子进程的数据段，堆栈段分配相应的物理空间，至此二者各自有各自的物理空间，互不影响。而代码段则继续共享父进程的物理空间，因为两者的代码完全相同，

但如果是因为exec,，由于二者的执行的代码不同，则也需为子进程分配代码段的物理空间。



> \1. 系统调用exec是以**新的进程去代替原来的进程**，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的
>
> 进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。



## 2. 详细

现在有一个父进程P1,这是一个主体，那么它是有灵魂也就身体的。现在在其虚拟地址空间（有相应的数据结构表示）上有：正文段，数据段，堆，栈这四个部分，相应的，内核要为这四个部分分配各自的物理块。即：正文段块，数据段块，堆块，栈块。至于如何分配，这是内核去做的事，在此不详述。

## 3. 关于fork函数

在子进程中返回0，而在父进程中返回子进程的id

```c
#include<unistd.h>
pid_t fork(void);
//返回：在子进程中返回0，在父进程中返回子进程的id，出错返回-1.
```

fork在子进程中返回0而不是父进程ID的原因在于：任何子进程只有一个父进程，而子进程总是可以通过调用getpid**取得父进程的ID**,如果父进程想要跟踪所有子进程的ID，那么它必须记录每次调用fork的返回值，所以**父进程返回的是子进程的进程ID**。



相反，父进程可以有许多子进程，而且无法获得各个子进程的进程ID。如果父进程想要跟踪所有子进程的ID，那么它必须记录每次调用fork的返回值，所以**父进程返回的是子进程的进程ID**。



fork有两个典型的用法：

1.**一个进程创建一个自身的拷贝**，这样每个拷贝都可以在另一个拷贝执行其他任务的同时处理各自的某个操作。这是网络服务器的典型用法。

2.**一个进程想要执行另一个程序**。既然创建新进程的唯一方法为调用fork，该进程于是首先调用fork创建一个自身的拷贝，然后其中一个拷贝（通常为子进程）调用**exec**把自身替换成新的程序。这是诸如shell之类程序的典型用法。



## ４. 关于exec函数

```c
#include<unistd.h>
int execl(const char *pathname, const char *arg0,.../* (char *)0 */);
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0,.../* (char *)0,char *const envp[] */);
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0,.../* (char *)0 */);
int execvp(const char *filename, char *const argv[]);
//所有六个函数返回：-1——失败，无返回——成功
```



从上面我们已经知道了fork会创建一个子进程。子进程的是父进程的副本。
exec函数的作用就是：**装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务**。

exec**系列函数在执行时会直接替换掉当前进程的地址空间**。
我去画张图来理解一下：



![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040109272624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rlcm5lbmNlX3px,size_16,color_FFFFFF,t_70)



现在P1用fork()函数为进程创建一个子进程P2

内核：



- 复制P1的正文段，数据段，堆，栈这四个部分，注意是其内容相同。
- 为这四个部分分配物理块，P2的：正文段－＞PI的正文段的物理块，其实就是不为P2分配正文段块，让P2的正文段指向P1的正文段块，数据段－＞P2自己的数据段块（为其分配对应的块），堆－＞P2自己的堆块，栈－＞P2自己的栈块。
  

如下图所示：**从左到右大的方向箭头表示复制内容**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040109333288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rlcm5lbmNlX3px,size_16,color_FFFFFF,t_70)

## ５．Copy On Write技术原理

> **内核只为新生成的子进程创建虚拟空间结构**，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。  也就是只拷贝页表

'COW`技术好处是什么》

- COW技术可**减少分配和复制大量资源时带来的瞬间延时**。
- COW技术**可减少不必要的资源分配**。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

Copy On Write技术缺点是什么？

- 如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断page-fault)，这样就得不偿失



几句话总结Linux的Copy On Write技术：

fork出的子进程共享父进程的物理空间，当父子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享父进程的)。
fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用exec()把当前进程映像替换成新的进程文件，完成自己想要实现的功能。



Linux文件系统



![image-20210824200541831](D:\Typora图片\image-20210824200541831.png)

上图是 Linux 文件系统的一个整体结构，无论是什么版本的 Linux 发行版，根目录 `/` 基本上就是这些文件。不要害怕这么多文件夹，大部分都不需要你操心，只要大概了解它们是干啥的就行了。

# /bin 和 /sbin

`bin` 是 `Binary` 的缩写，**存放着可执行文件或可执行文件的链接**（类似快捷方式），如下图：

![image-20210824200650966](D:\Typora图片\image-20210824200650966.png)



你可以看到 `cp`, `chmod`, `cat` 等常用命令都在这里，`/bin` 目录中的文件都是可执行的二进制文件，而不是文本文件。



与 `/bin` 类似的是 `/sbin` 目录，System Binary 的缩写，这里存放的命令可以对系统配置进行操作。普通用户可能可以使用这里的命令查看某些系统状态，但是如果想更改配置，就需要 `sudo` 授权或者切换成超级用户。

![image-20210824200826617](D:\Typora图片\image-20210824200826617.png)

可以看到一些熟悉的命令，比如 `ifconfig`, `iptables`。普通用户可以使用 `ifconfig` 查看网卡状态，但是想配置网卡信息，就需要授权了。

### /boot

![image-20210824200854359](D:\Typora图片\image-20210824200854359.png)

这里是系统启动需要的文件，你可以看到 `grub` 文件夹，它是常见的开机引导程序。我们不应该乱动这里的文件。

# /dev

`dev` 是 `device` 的缩写，这里存放这**所有的设备文件**。在 Linux 中，所有东西都是以文件的形式存在的，包括硬件设备。

比如说，`sda`, `sdb` 就是我电脑上的两块硬盘，后面的数字是硬盘分区：

![image-20210824201055568](D:\Typora图片\image-20210824201055568.png)

鼠标、键盘等等设备也都可以在这里找到。

# /etc

这个目录经常使用，存放很多程序的配置信息，比如包管理工具 apt：

![image-20210824201114640](D:\Typora图片\image-20210824201114640.png)

在 `/etc/apt` 中就存放着对应的配置，比如说镜像列表（我配置的阿里云镜像）：

![image-20210824201302214](D:\Typora图片\image-20210824201302214.png)

如果你要修改一些系统程序的配置，十有八九要到 `etc` 目录下寻找。



# /lib

`lib` 是 Library 的缩写，类似于 Windows 系统中存放 `dll` 文件的库，包含 bin 和 sbin 中可执行文件的依赖。

也可能出现 `lib32` 或 `lib64` 这样的目录，和 `lib` 差不多，只是操作系统位数不同而已。

# /media

这里会有一个**以你用户名命名的文件夹，里面是自动挂载的设备，比如 U 盘，移动硬盘，网络设备等**。

比如说我在电脑上插入一个 U 盘，系统会把 U 盘自动给我挂载到 `/media/fdl` 这个文件夹里（我的用户名是 fdl），如果我要访问 U 盘的内容，就可以在那里找到。



# /mnt

这也是和设备挂载相关的一个文件夹，一般是空文件夹。`media` 文件夹是系统自动挂载设备的地方，**这里是你手动挂载设备的地方**。

比如说，刚才我们在 `dev` 中看到了一大堆设备，你想打开某些设备看看里面的内容，就可以通过命令把设备挂载到 `mnt` 目录进行操作。

不过一般来说，现在的操作系统已经很聪明了，像挂载设备的操作几乎都不用你手动做，都被自动挂载到 `media` 目录了。



# /opt

`opt` 是 Option 的缩写，这个文件夹的使用比较随意，一般来说我们自己在浏览器上下载的软件，安装在这里比较好。当然，包管理工具下载的软件也可能被存放在这里。

![image-20210824201712417](D:\Typora图片\image-20210824201712417.png)

比如我在这里存放了 Chrome 浏览器（google），网易云音乐（netease），CLion IDE 等等软件的文件夹。

# /proc

`proc` 是 `process` 的缩写，这里存放的是**全部正在运行程序的状态信息**。

![image-20210824201726430](D:\Typora图片\image-20210824201726430.png)



你会发现 `/proc` 里面有一大堆数字命名的文件夹，这个数字其实是 Process ID（PID），文件夹里又有很多文件。

前面说过，Linux 中一切都以文件形式储存，类似 `/dev`，这里的文件也不是真正的文件，而是程序和内核交流的一些信息。比如说我们可以查看当前操作系统的版本，或者查看 CPU 的状态：

![image-20210824201809490](D:\Typora图片\image-20210824201809490.png)

如果你需要调试应用程序，`proc` 目录中的信息也许会帮上忙。

# /root

这是 root 用户的家目录，普通用户需要授权才能访问。

# /run 和 /sys

用来存储某些程序的运行时信息和系统需要的一些信息。比如说这个文件：

```shell
sudo vim /sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-eDP-1/intel_backlight/brightness
```

里面存储着一个数字，是你的显卡亮度，你修改这个数字就可以修改屏幕亮度。

需要注意的是，这两个位置的数据都存储在内存中，所以一旦重启，`/run` 和 `/sys` 目录的信息就会丢失，所以不要试图在这里存放任何文件。

# /srv

`srv` 是 `service` 的缩写，主要用来存放服务数据。

对于桌面版 Linux 系统，这个文件夹一般是空的，但是对于 Linux 服务器，Web 服务或者 FTP 文件服务的资源可以存放在这里。



# /tmp

`tmp` 是 `temporary` 的缩写，存储一些程序的临时文件。

![image-20210824201954503](D:\Typora图片\image-20210824201954503.png)

临时文件可能起到很重要的作用。比如经常听说某同学的 Word 文档崩溃了，好不容易写的东西全没了，Linux 的很多文本编辑器都会在 `/tmp` 放一份当前文本的 copy 作为临时文件，如果你的编辑器意外崩溃，还有机会在 `/tmp` 找一找临时文件抢救一下。

比如上图的 `VSCode Crashes` 应该就是 VScode 编辑器存放临时文件的地方。

当然，`tmp` 文件夹在系统重启之后会自动被清空，如果没有被清空，说明系统删除某些文件失败，也许需要你手动删除一下

# /usr

`usr` 是 Universal System Resource 的缩写，这里存放的是一些**非系统必须的资源**，比如用户安装的应用程序。

![image-20210824202101129](D:\Typora图片\image-20210824202101129.png)

`/usr` 和 `/usr/local` 目录中又含有 `bin` 和 `sbin` 目录，也是存放可执行文件（命令），但和根目录的 `bin` 和 `sbin` 不同的是，这里大都是用户使用的工具，而非系统必须使用的。

比如说 `/usr/bin` 中含有我通过包管理工具安装的应用程序 Chrome 浏览器和 goldendict 字典的可执行文件：

![image-20210824202117716](D:\Typora图片\image-20210824202117716.png)

值得一提的是，如果使用 Linux 桌面版，有时候在桌面找不到应用程序的快捷方式，就需要在 `/usr/share/applications` 中手动配置桌面图标文件：

![image-20210824202148383](D:\Typora图片\image-20210824202148383.png)



# /var

`var` 是 `variable` 的缩写，这个名字是历史遗留的，现在该目录最主要的作用是存储日志（log）信息，比如说程序崩溃，防火墙检测到异常等等信息都会记录在这里。

这是我的 `/var/log` 目录：

![image-20210824202302585](D:\Typora图片\image-20210824202302585.png)

日志文件不会自动删除，也就是说随着系统使用时间的增长，你的 `var` 目录占用的磁盘空间会越来越大，也许需要适时清理一下。

# /home

最后说 `home` 目录，这是普通用户的家目录。在桌面版的 Linux 系统中，用户的家目录会有下载、视频、音乐、桌面等文件夹，这些没啥可说的，我们说一些隐藏的比较重要的文件夹（Linux 中名称以 `.` 开头就是隐藏文件）。

这是我的家目录的部分文件：

![image-20210824202317621](D:\Typora图片\image-20210824202317621.png)

其中 `.cache` 文件夹存储应用缓存数据，`.config` 文件夹存储了一部分应用程序的配置，比如说我的 Chrome 浏览器配置就是那里面。但是还有一部分应用程序并不把配置储存在 `.config` 文件夹，而是自己创建一个隐藏文件夹，存放自己的配置文件等等信息，比如你可以看到 Intellij 的配置文件就不在 `.config` 中。

最后说 `.local` 文件夹，有点像 `/usr/local`，里面也有 `bin` 文件夹，也是存放可执行文件的。比如说我的 python pip 以及 pip 安装的一些工具，都存放在 `～/.local/bin` 目录中。**但是，存在这里的文件，只有该用户才能使用。**

这就是为什么，有时候普通用户可以使用的命令，用 sudo 或者超级用户却被告知找不到该命令。因为有的命令是特定用户家目录里的，被添加到了该用户的 `PATH` 环境变量里，他可以直接用。你超级用户想用当然可以，但是得写全绝对路径才行。

# 最后总结

如果修改系统配置，就去 `/etc` 找，如果修改用户的应用程序配置，就在用户家目录的隐藏文件里找。

你在命令行里可以直接输入使用的命令，其可执行文件一般就在以下几个位置：



```
/bin    
/sbin
/usr/bin
/usr/sbin
/usr/local/bin
/usr/local/sbin
/home/USER/.local/bin
/home/USER/.local/sbin
```

如果你写了一个脚本/程序，想在任何时候都能直接调用，可以把这个脚本/程序添加到上述目录中。

如果某个程序崩溃了，可以到 `/val/log` 中尝试寻找出错信息，到 `/tmp` 中寻找残留的临时文件。

设备文件在 `/dev` 目录，但是一般来说系统会自动帮你挂载诸如 U 盘之类的设备，可以到 `/media` 文件夹访问设备内容。



## 进程管理

进程是处于执行期的程序以及相关的资源的总称。 线程是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器



进程描述符：内核把进程的列表存放在叫**做任务队列的双向循环链表中**，链表中的每一项都是类型为task_struct的，被称为进程描述符的结构，进程描述符中包含了一个具体进程的所有信息，比如**其打开的文件、进程的地址空间、挂起的信号、进程的状态**等。

![image-20210927194707266](D:\Typora图片\image-20210927194707266.png)



Linux不特别区分进程和线程，**线程被当做一种特殊的进程对待**，`**内核调度的对象是线程而不是进程**`。

```java
struct task_struct{
    //进程状态
    long state;
    //虚拟内存结构体
    struct mm_struct *mm;
    //进程号 
    pid_t pid;
    //指向父进程的指针
    struct task_struc __rcu *parent;
    //子进程列表
    struct list_head children;
    //存放文件系统信息的指针
    struct fs_struct        *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct        *files;
}
```



分配进程描述符

Linux通过**slab（一种内存分配机制）分配task_struct结构**（task_struct分配在slab管理的缓存上），以此达到对象复用和缓存着色的目的

具体而言就是在进程内核栈的栈顶创建一个新的结构struct_thread_info,而该结构中有一个指向task_struct的指针

![image-20210927195707767](D:\Typora图片\image-20210927195707767.png)



![image-20210927195806002](D:\Typora图片\image-20210927195806002.png)



`PID`：内核通过一个唯一的进程标识值PID（int类型）来标识每个进程，内核将其放在各个进程的进程描述符中。PID的最大值默认为32768，可以通过修改/proc/sys/kernel/pid_max来提高（最高可达400万）。



## 进程、轻量级进程和线程



从内核的观点看，进程的目的就是担当**系统资源(CPU时间、内存等)的实体**

![image-20211215211901457](E:\TyporaPic\image-20211215211901457.png)



### 这个其实就是用户线程

![image-20211215212011225](E:\TyporaPic\image-20211215212011225.png)

这种多线程的实现方式不那么令人满意。例如，假设一个象棋程序，使用两个线程

其中一个图形化棋盘，等待人类选手的移动并显示计算机的移动，

而另一个思考棋的下一步移动。

![image-20211215213318751](E:\TyporaPic\image-20211215213318751.png)



**Linux使用轻量级进程(lightweight process)**对多线程应用程序提供更好的支持。

两个轻量级进程基本上可以**共享一些资源，诸如地址空间、打开的文件等等**。只要其中一个修改共享资源，另一个就立即查看这种修改。当然，两个线程访问共享资源时就必须同步他们自己。



实现多线程应用程序的一个简单方式就是把轻量级进程于每个线程关联起来。这样，线程之间就可以通过简单的**共享同一内存地址空间，同一打开文件集**等来访问相同的应用程序数据结构集

同时每个线程都可以由内核独立调度，以便一个睡眠的同时另一个仍然是可运行的。











### 完全公平调度算法（CFS）

始使用称为`完全公平调度算法`的进程调度算法，该算法不直接分配时间片到进程，而是将处理器的使用比划分给进程，nice值越高的使用比越低

时间记账：

CFS使用调度器实体结构struct sched_entity来跟踪进程运行并记账，sched_entity在task_struct中以一个名为se的成员变量被嵌入，sched_entity中有一个名为vruntime的变量用来`存放进程的虚拟运行时间`，该运行时间称为`虚拟实时`，其值的计算是经过了所有可运行进程总数的标准化，即被加权的，单位为ns，因此和定时器的节拍不相关。CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。

进程选择：

它会挑一个具有最小vruntime的进程`，这也是CFS调度算法的核心。`CFS使用**红黑树（rbtree）来组织可运行的进程队列**

睡眠和唤醒:

睡眠就是被阻塞，此时进程处于一个特殊的不可执行的状态，**进程把自己标志成睡眠状态，从可执行红黑树中移除，放入等待队列**，然后调用schedule()选择和执行一个其他进程

唤醒的过程则相反，进程被设置为可执行状态，然后再从等待队列中移到可执行二叉树中。





## 什么是中断？

CPU芯片外部硬件电路产生的电信号相对应。

中断通常分为 同步中断 和异步中断

同步中断称为异常 异步中断 称为中断

![image-20211215195556039](E:\TyporaPic\image-20211215195556039.png)





## 什么是硬中断 软中断？

本质上来说中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。

如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，

跳到中断处理程序的入口点，进行中断处理。

![img](https://img-blog.csdn.net/20140325105401500)

 

(1) 硬中断

由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包

的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。

 

(2) 软中断

为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间

就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。

 

(3) 中断嵌套

Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断

除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。

 

(4) 软中断指令

int是软中断指令。

中断向量表是中断号和中断处理函数地址的对应表。

int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。

 

(5)硬中断和软中断的区别

软中断是执行中断指令产生的，而硬中断是由外设引发的。

硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。

硬中断是可屏蔽的，软中断不可屏蔽。

硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。

软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。 


以进程发起recv为例 看看中断 和 阻塞的作用

一、中断

一般而言，由硬件产生的信号需要cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当cpu完成对硬件的响应后，再重新执行用户程序。

中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9tSTZvN0gwNXNoZ281ZHduTXlOZXU1aWJ1RGFrdWRPSlRacjlaeEYzMXFneGo5ME1QYldHdFdvck44aWN3ZVFraWNuRFl2TmRpYlJrNTJjWHhpY3NpYWZ4MUxkUS82NDA?x-oss-process=image/format,png)

对于网络数据而言，网卡接收到的数据，会把数据写入到内存中。然后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。

二、进程阻塞

阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select和epoll都是阻塞方法。

对于阻塞来说，是不占用CPU资源的。下面我们看下“进程阻塞为什么不占用cpu资源？”

操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。

1.运行状态是进程获得cpu使用权，正在执行代码的状态；
2.等待状态是阻塞状态，比如上述程序运行到recv时，
程序会从运行状态变为等待状态，接收到数据后又变回运行状态。
操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。下面演示了这个运行和阻塞的调度情况。



第一步：当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。

等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9tSTZvN0gwNXNoZ281ZHduTXlOZXU1aWJ1RGFrdWRPSlQ2RFdzTkRHRHhRMU1BOW5pY1E2eEwzRUdHcE80UFhxcGtZTGdKaWFVUHdTQUlnTDI3Tk8wSFFsdy82NDA?x-oss-process=image/format,png)

第二步：当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。

由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。

所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9tSTZvN0gwNXNoZ281ZHduTXlOZXU1aWJ1RGFrdWRPSlRlZnNyaWFJTHV5R3BlQWlhZlJyRjlCV3hKWWd1T0d3aWFqaHBuUUJCV2ljRTE0R01VUTloUWx2VmhRLzY0MA?x-oss-process=image/format,png)

备注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。

第三步：内核接收数据

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9tSTZvN0gwNXNoZ281ZHduTXlOZXU1aWJ1RGFrdWRPSlRjWDV2T2tFSXFLSFFsdW51YU5va1kwcnlQTDhqNENQWWJ0ZEJjalZyWTNpYlQ0aWJ0Y3RnYVRTQS82NDA?x-oss-process=image/format,png)

进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面（步骤④），再唤醒进程A（步骤⑤），重新将进程A放入工作队列中。

第四步：唤醒进程

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9tSTZvN0gwNXNoZ281ZHduTXlOZXU1aWJ1RGFrdWRPSlRJaWNncXZZMXBNdHJScTZhOXJWN3NCN0tMMVdOZjB6VFVNVTY3TnVNR1lmZ1lBMTZFcmJla3J3LzY0MA?x-oss-process=image/format,png)

当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。









进程的地址空间

进程的地址空间(address space) 由语序进程使用的全部线性地址组成。每个进程所看到的线性地址集合是不同的，一个进程所使用的地址与另外一个进程所会用的地址没有什么关系。



内核通过所谓线性区的资源来标识线性地址区间，线性区是由起始线性地址、长度和一些访问权限来描述的。



进程可能通过调用类似malloc()这样的函数扩展自己的动态区(堆) 结果是，内核可能决定扩展给这个堆所分配的线性区

![image-20211215210359758](E:\TyporaPic\image-20211215210359758.png)



内存描述符

与进程地址空间有关的全部信息都包含一个劲叫做内存描述符(memory desciptor) 的数据描述符

这个结构的类型为mm_struct,**进程描述符的mm字段就指向这个结构**

内存描述符的字段如表9-2所示

![image-20211215210703350](E:\TyporaPic\image-20211215210703350.png)





### 


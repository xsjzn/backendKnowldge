# 面试题

1.epoll水平触发和边缘触发使用场景

1. epoll默认是水平触发（LT）

2. LT通俗来说 只要缓冲区有数据 epoll wait函数就一直返回；边缘触发来讲 只有socket状态发生变化，epoll_wait函数才会返回。

3. 水平触发优缺点及应用场景：

   1. 优点：当socket进行通信时，保证了数据的完整性，**进行IO操作的时候，如果还有数据，就会一直的通知你**。
   2. 缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，**所以占用了大量的内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。**效率来讲也是很低的。
   3. 应用场景

4. 边沿触发优、缺点及应用场景：

   优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。

   缺点：不能保证数据的完整。不能及时的取出所有的数据。

   应用场景：处理大数据。使用non-block模式的socket。

水平触发（LT）：读缓冲区非空就会一直触发，写缓冲区只要不满就会一直触发写事件。
边缘触发（ET）：读缓冲区空转非空（有新消息）的时候触发一次，写缓冲区从满到非满的时候（空出来可以写了）触发一次。



总结：

如果我们用水平触发不用担心数据有没有读完因为下次epoll返回时，没有读完的socket依然会被返回，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此**长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满**，所以**在水平触发模式下我们一般不关注可写事件**，而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次或者多次。

所以有时候我们也会用到边缘触发，但是这种模式下在读数据的时候一定要注意，因为如果一次可读事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。





个人看法：

对于读事件：如果业务可以保证每次都可以读完，那就可以使用ET，否则使用LT

对于写事件：如果一次性可以写完那就可以使用LT，写完删除写事件就可以了.

但是如果写的数据很大也不在意延迟，那么就可以使用ET，因为ET可以保证在发送缓冲区变为空时才再次通知（而LT则是发送缓冲区空了就可以通知就绪，这样就每次触发就只能写一点点数据，内核切换开销以及内存拷贝开销过大）

操作系统内存管理





6.8大小的水果袋，给定m个水果，要求正好装满袋子，返回6、8大小袋子的数量，如果不能正好装满都返回0。用的DP做的







java如何修改字节码



场景题：怎么保证订单只能退款一次(幂等性？)

## 1、token机制

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

![img](https://pic2.zhimg.com/v2-a813e4f94b89049877fe513264e0eb5d_b.jpg)

具体流程步骤：

1.客户端会先发送一个请求去获取 token，服务端会生成一个**全局唯一的 ID 作为 token** 保存在 redis 中，同时把这个 ID 返回给客户端

2.客户端第二次调用业务请求的时候必须携带这个 token

3.服务端会校验这个token,如果校验成功，则执行业务，并删除 redis 中的 token

4.如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端



注意：

1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成 （涉及分布式ID  都是基于雪花算法的 是一个64位的long 类型 第一个bit是标识部分，时间戳41bit 工作机器id 10bit 可以前5位作为数据中心机房标记 后5位作为单机房机器标识 序列号12bit ）
   1. uid-generator的 workid 可以自定义 默认是 往数据库插入一条数据 而返回的自增id就是该机器的workId，而数据由host port组成
   2. 美团的Leaf支持号段模式 也支持雪花算法 snowflake也是在workid上做文章 是有zk的顺序ID来生成的

## **2、基于 mysql 实现**

![img](https://pic1.zhimg.com/v2-dc3df46efad1657a9785aebbc2069b5c_b.jpg)



具体流程步骤：

1. 建立一张去重表，其中**某个字段需要建立唯一索引**。
2. 客户端去请求服务端，服务端会将这次请求信息插入一张去重表中
3. 因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑
4. 如果插入失败，则代表已经执行过当前请求，直接返回



例如 退款场景下 订单id



## **3、基于 redis 实现**

这种实现方式是基于 SETNX 命令实现的

SETNX [key value](https://www.zhihu.com/search?q=key+value&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"345512692"})：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。

该命令在设置成功时返回 1，设置失败时返回 0。

示意图如下：

![img](https://pic2.zhimg.com/v2-6ae389fa7bcb099a8f8a6eaf89f5f46d_b.jpg)

具体流程步骤：

1. 客户端先请求服务端，会拿到一个能代表这次请求业务的**唯一字段**
2. 将该字段以 SETNX 的方式存入 redis 中，并根据业务设置相应的超时时间
3. 如果**设置成功，证明这是第一次请求，则执行后续的业务逻辑**
4. 如果设置失败，则代表已经执行过当前请求，直接返回

例如 退款场景 订单id是唯一字段的话 就可以在setnx中 把 订单id作为key





什么情况下会出现oom？



# 堆溢出

这种场景最为常见，报错信息：`java.lang.OutOfMemoryError: Java heap space`

1.大对象分配

2.可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。



解决方法：

1.检查是否存在大对象的分配，最有可能的是大数组分配 还可以看看大文件读取代码

2.通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题

3.如果没有找到明显的内存泄露，使用 -Xmx 加大堆内存

4.还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性



堆内存溢出如何排查？

Java的堆用于存储对象实例，只要不断地创建对象，并且保证GC root 到对象之间有可达路径，就无法被收集器回收。
在java工程的目录下新建一个类，这里命名为MemoryController，代码如下：

```java
@RestController
public class MemoryController {
    private List<TestEntity>  heapList = new ArrayList<>();
    /**
     * -Xmx32M -Xms32M
     * */
    @GetMapping("/heap")
    public String heap() {
        long i=1l;
        while(true) {
            heapList.add(new TestEntity(i++, UUID.randomUUID().toString()));
        }
    }
}
```

内存泄漏

《深入理解Java虚拟机》书中给出这种情况的解决思路：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529132021280.png)

（1)如果是内存泄漏，查GCRoot引用链，打印出引用链信息，就基本可以定位泄露代码的为位置。

(2）如果不存在泄露，也就是内存中的对象确实都必须存活，就检查虚拟机的堆参数。看看-Xmx和-Xms在机器物理内存的基础上可否再调大。







# 永久代/元空间溢出

```java
java.lang.OutOfMemoryError: PermGen spacejava.lang.OutOfMemoryError: Metaspace
```



原因：

永久代是hotspot虚拟机对方法区的具体实现，存放了被JVM加载的类信息.常量/静态变量/JIT编译后的代码等

jdk8后 元空间代替了永久代，元空间使用的是本地内存，还有其他细节变化

字符串常量由永久代转移到堆中和永久代相关的JVM参数已移除

可能的原因有如下几种：

1. 在Java7之前，频繁的错误使用String.intern()方法
2. 运行期间生成了大量的代理类，导致方法区被撑破
3. 应用长时间运行

解决方法
因为该OOM原因比较简单，解决方法有如下几种：
1、检查是否永久代空间或者元空间设置的过小
2、检查代码中是否存在大量的反射操作
3、dump之后通过mat检查是否存在大量由于反射生成的代理类
4、放大招，重启JVM

GC overhead limit exceeded
这个异常比较的罕见，报错信息：java.lang.OutOfMemoryError：GC overhead limit exceeded
原因
这个是JDK6新加的错误类型，一般都是堆太小导致的。Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。
解决方法
1、检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。
2、添加参数 -XX:-UseGCOverheadLimit 禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space。
3、dump内存，检查是否存在内存泄露，如果没有，加大内存。

方法栈溢出
报错信息：java.lang.OutOfMemoryError : unable to create new native Thread

原因
出现这种异常，基本上都是创建的了大量的线程导致的，以前碰到过一次，通过jstack出来一共8000多个线程。
解决方法

1、通过 -Xss 降低的每个线程栈大小的容量
2、线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：
/proc/sys/kernel/pid_max
/proc/sys/kernel/thread-maxmaxuserprocess（ulimit -u）
/proc/sys/vm/maxmapcount

非常规溢出
下面这些OOM异常，可能大部分的同学都没有碰到过，但还是需要了解一下
分配超大数组
报错信息 ：java.lang.OutOfMemoryError: Requested array size exceeds VM limit

这种情况一般是由于不合理的数组分配请求导致的，在为数组分配内存之前，JVM 会执行一项检查。要分配的数组在该平台是否可以寻址(addressable)，如果不能寻址(addressable)就会抛出这个错误。
解决方法就是检查你的代码中是否有创建超大数组的地方。

swap溢出
报错信息 ：java.lang.OutOfMemoryError: Out of swap space
这种情况一般是操作系统导致的，可能的原因有：
1、swap 分区大小分配不足；
2、其他进程消耗了所有的内存。
解决方案：
1、其它服务进程可以选择性的拆分出去 2、加大swap分区大小，或者加大机器内存大小

本地方法溢出
报错信息 ：java.lang.OutOfMemoryError: stack_trace_with_native_method
本地方法在运行时出现了内存分配失败，和之前的方法栈溢出不同，方法栈溢出发生在 JVM 代码层面，而本地方法溢出发生在JNI代码或本地方法处。
这个异常出现的概率极低，只能通过操作系统本地工具进行诊断，难度有点大，还是放弃为妙。





具体场景：



1.程序中有死循环 不断创建新的对象

2.内存泄漏

当出现了内存溢出，你怎么排错。







2msl是如何测算出来的

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置，

初始值，但ttl并不是存在的具体时间，而是一个IP数据报可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。TTL与MSL是有关系的但不是简单的相等关系，MSL要大于TTL。

 









## 网关如何保证可用性：

1.集群部署

2.负载均衡

3.健康检查

4.节点自动重启

5.熔断

6.服务降级

7.接口重试





rpc技术选型？为什么选择zk 为什么使用netty 为什么序列化使用 

grpc和dubbo





## 大数据算法题：代码实现





#### [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。

当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。

连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。

请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。

 

示例 1：

输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
示例 2：

输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
示例 3：

输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]



题解：



BFS

如果发现 下一跳是边界 就对当前格子进行染色

如果下一跳 访问过了 直接跳过 

最后 如果下一跳已经不是这种颜色 那么当前格子也属于联通分量的边界了

```java
class Solution {
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        int[][] directions={{1,0},{0,1},{0,-1},{-1,0}};
        int m=grid.length,n=grid[0].length;
        int expextedColor=grid[row][col];
        Queue<int[]> queue=new LinkedList<>();
        queue.offer(new int[]{row,col});
        boolean[][] vis=new boolean[m][n];
        while(!queue.isEmpty()){
            int[] cur=queue.poll();
            vis[cur[0]][cur[1]]=true;
            for(int[] d:directions){
                
                int nr=cur[0]+d[0];
                int nc=cur[1]+d[1];
                // System.out.println("nr:"+nr+" nc:"+nc);
                if(nr<0||nr>=m||nc<0||nc>=n){
                    grid[cur[0]][cur[1]]=color;
                    continue;
                }
                if(vis[nr][nc]){
                    continue;
                }
                if(grid[nr][nc]!=expextedColor){
                    grid[cur[0]][cur[1]]=color;
                    continue;
                }
                queue.offer(new int[]{nr,nc});
            }
        }
        return grid;
    }
}
```



dfs做法 思路和 BFS一致

```java
class Solution {
    int m,n;
    int[][] directions={{1,0},{0,1},{0,-1},{-1,0}};
    boolean[][] vis;
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        if(grid.length==0||grid[0].length==0){
            return grid;
        }
        m=grid.length;
        n=grid[0].length;
        vis=new boolean[m][n];
        dfs(grid,row,col,color,grid[row][col]);
        return grid;
    }
    //从 row col出发 找出 所有边界并染色成color 
    private void dfs(int[][] grid,int row,int col,int color,int expectedColor){
        if(row<0||row>=m||col<0||col>=n){
            return;
        }
        vis[row][col]=true;
        for(int[] d:directions){
            int nr=row+d[0];
            int nc=col+d[1];
            
            //下一步是边界了
            if(nr<0||nr>=m||nc<0||nc>=n){
                grid[row][col]=color;
                continue;
            }
            //已经访问过了
            if(vis[nr][nc]){
                continue;
            }  
            //不是预期颜色
            if(grid[nr][nc]!=expectedColor){
                grid[row][col]=color;
                continue;
            }
            dfs(grid,nr,nc,color,expectedColor);
        }
    }

}
```



时间复杂度O（m*n）

空间复杂度O（m*n）

也可以像官方题解那样 dfs就做一件事 判断是不是边界 是边界加入list dfs或者bfs结束了 再进行染色

```java
class Solution {
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        List<int[]> borders = new ArrayList<>();
        int originalColor = grid[row][col];
        visited[row][col] = true;
        dfs(grid, row, col, visited, borders, originalColor);
        for (int i = 0; i < borders.size(); i++) {
            int x = borders.get(i)[0], y = borders.get(i)[1];
            grid[x][y] = color;
        }
        return grid;
    }

    private void dfs(int[][] grid, int x, int y, boolean[][] visited, List<int[]> borders, int originalColor) {
        int m = grid.length, n = grid[0].length;
        boolean isBorder = false;
        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < 4; i++) {
            int nx = direc[i][0] + x, ny = direc[i][1] + y;
            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                isBorder = true;
            } else if (!visited[nx][ny]){
                visited[nx][ny] = true;
                dfs(grid, nx, ny, visited, borders, originalColor);
            }                
        }
        if (isBorder) {
            borders.add(new int[]{x, y});
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/coloring-a-border/solution/bian-kuang-zhao-se-by-leetcode-solution-0h5l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



BFS

```java
class Solution {
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        List<int[]> borders = new ArrayList<>();
        int originalColor = grid[row][col];
        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Deque<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{row, col});
        visited[row][col] = true;
        while (!q.isEmpty()) {
            int[] node = q.poll();
            int x = node[0], y = node[1];

            boolean isBorder = false;
            for (int i = 0; i < 4; i++) {
                int nx = direc[i][0] + x, ny = direc[i][1] + y;
                if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                    isBorder = true;
                } else if (!visited[nx][ny]) {
                    visited[nx][ny] = true;
                    q.offer(new int[]{nx, ny});
                }         
            }
            if (isBorder) {
                borders.add(new int[]{x, y});
            }
        }
        for (int i = 0; i < borders.size(); i++) {
            int x = borders.get(i)[0], y = borders.get(i)[1];
            grid[x][y] = color;
        }
        return grid;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/coloring-a-border/solution/bian-kuang-zhao-se-by-leetcode-solution-0h5l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

 

示例 1：

输入：a = 2, b = [3]
输出：8
示例 2：

输入：a = 2, b = [1,0]
输出：1024
示例 3：

输入：a = 1, b = [4,3,3,8,5,2]
输出：1
示例 4：

输入：a = 2147483647, b = [2,0,0]
输出：1198


提示：

1 <= a <= 231 - 1
1 <= b.length <= 2000
0 <= b[i] <= 9
b 不含前导 0



题解：

```java
class Solution {
    private final int MOD=1337; 
    public int superPow(int a, int[] b) {
        int res=1;
        for(int i=b.length-1;i>=0;i--){
            res=res*quickPow(a,b[i])%MOD;
            a=quickPow(a,10)%MOD;
        }
        return res;
    }

    private int quickPow(int a,int b){
        long res=1;
        a=a%MOD;
        while(b!=0){
            if((b&1)!=0){
                res=res*a%MOD;
            }
            a=a*a%MOD;
            b>>=1;
        }
        return (int)res%MOD;
    }
}
```



递归写法

```java
class Solution {
    final int MOD=1337;
    public int superPow(int a, int[] b) {
        return dfs(a,b,b.length-1);
    }

    private int dfs(int a,int[] b,int last){
        if(last==-1){
            return 1;
        }
        return (quickPOW(dfs(a,b,last-1),10)*quickPOW(a,b[last]))%MOD;
    }
    private int quickPOW(int a,int b){
        int ans = 1;
        a %= MOD;
        while (b != 0) {
            if ((b & 1) != 0) ans = ans * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return ans;
    }
}
```


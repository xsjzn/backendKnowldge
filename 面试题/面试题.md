# 面试题

1.epoll水平触发和边缘触发使用场景

1. epoll默认是水平触发（LT）

2. LT通俗来说 只要缓冲区有数据 epoll wait函数就一直返回；边缘触发来讲 只有socket状态发生变化，epoll_wait函数才会返回。

3. 水平触发优缺点及应用场景：

   1. 优点：当socket进行通信时，保证了数据的完整性，**进行IO操作的时候，如果还有数据，就会一直的通知你**。
   2. 缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，**所以占用了大量的内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。**效率来讲也是很低的。
   3. 应用场景

4. 边沿触发优、缺点及应用场景：

   优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。

   缺点：不能保证数据的完整。不能及时的取出所有的数据。

   应用场景：处理大数据。使用non-block模式的socket。

水平触发（LT）：读缓冲区非空就会一直触发，写缓冲区只要不满就会一直触发写事件。
边缘触发（ET）：读缓冲区空转非空（有新消息）的时候触发一次，写缓冲区从满到非满的时候（空出来可以写了）触发一次。



总结：

如果我们用水平触发不用担心数据有没有读完因为下次epoll返回时，没有读完的socket依然会被返回，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此**长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满**，所以**在水平触发模式下我们一般不关注可写事件**，而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次或者多次。

所以有时候我们也会用到边缘触发，但是这种模式下在读数据的时候一定要注意，因为如果一次可读事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。





个人看法：

对于读事件：如果业务可以保证每次都可以读完，那就可以使用ET，否则使用LT

对于写事件：如果一次性可以写完那就可以使用LT，写完删除写事件就可以了.

但是如果写的数据很大也不在意延迟，那么就可以使用ET，因为ET可以保证在发送缓冲区变为空时才再次通知（而LT则是发送缓冲区空了就可以通知就绪，这样就每次触发就只能写一点点数据，内核切换开销以及内存拷贝开销过大）

操作系统内存管理





6.8大小的水果袋，给定m个水果，要求正好装满袋子，返回6、8大小袋子的数量，如果不能正好装满都返回0。用的DP做的







java如何修改字节码



场景题：怎么保证订单只能退款一次(幂等性？)

## 1、token机制

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

![img](https://pic2.zhimg.com/v2-a813e4f94b89049877fe513264e0eb5d_b.jpg)

具体流程步骤：

1.客户端会先发送一个请求去获取 token，服务端会生成一个**全局唯一的 ID 作为 token** 保存在 redis 中，同时把这个 ID 返回给客户端

2.客户端第二次调用业务请求的时候必须携带这个 token

3.服务端会校验这个token,如果校验成功，则执行业务，并删除 redis 中的 token

4.如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端



注意：

1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成 （涉及分布式ID  都是基于雪花算法的 是一个64位的long 类型 第一个bit是标识部分，时间戳41bit 工作机器id 10bit 可以前5位作为数据中心机房标记 后5位作为单机房机器标识 序列号12bit ）
   1. uid-generator的 workid 可以自定义 默认是 往数据库插入一条数据 而返回的自增id就是该机器的workId，而数据由host port组成
   2. 美团的Leaf支持号段模式 也支持雪花算法 snowflake也是在workid上做文章 是有zk的顺序ID来生成的

## **2、基于 mysql 实现**

![img](https://pic1.zhimg.com/v2-dc3df46efad1657a9785aebbc2069b5c_b.jpg)



具体流程步骤：

1. 建立一张去重表，其中**某个字段需要建立唯一索引**。
2. 客户端去请求服务端，服务端会将这次请求信息插入一张去重表中
3. 因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑
4. 如果插入失败，则代表已经执行过当前请求，直接返回



例如 退款场景下 订单id



## **3、基于 redis 实现**

这种实现方式是基于 SETNX 命令实现的

SETNX [key value](https://www.zhihu.com/search?q=key+value&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"345512692"})：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。

该命令在设置成功时返回 1，设置失败时返回 0。

示意图如下：

![img](https://pic2.zhimg.com/v2-6ae389fa7bcb099a8f8a6eaf89f5f46d_b.jpg)

具体流程步骤：

1. 客户端先请求服务端，会拿到一个能代表这次请求业务的**唯一字段**
2. 将该字段以 SETNX 的方式存入 redis 中，并根据业务设置相应的超时时间
3. 如果**设置成功，证明这是第一次请求，则执行后续的业务逻辑**
4. 如果设置失败，则代表已经执行过当前请求，直接返回







什么情况下堆会出现oom？



2msl是如何测算出来的

出于工程上的考虑 首先要确保 ip报的ttl的 截止时间 





1. 当出现了内存溢出，你怎么排错。



网关如何保证可用性：

1.集群部署

2.负载均衡

3.健康检查

4.节点自动重启

5.熔断

6.服务降级

7.接口重试







大数据算法题：代码实现








# 面试题

1.epoll水平触发和边缘触发使用场景

1. epoll默认是水平触发（LT）

2. LT通俗来说 只要缓冲区有数据 epoll wait函数就一直返回；边缘触发来讲 只有socket状态发生变化，epoll_wait函数才会返回。

3. 水平触发优缺点及应用场景：

   1. 优点：当socket进行通信时，保证了数据的完整性，**进行IO操作的时候，如果还有数据，就会一直的通知你**。
   2. 缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，**所以占用了大量的内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。**效率来讲也是很低的。
   3. 应用场景

4. 边沿触发优、缺点及应用场景：

   优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。

   缺点：不能保证数据的完整。不能及时的取出所有的数据。

   应用场景：处理大数据。使用non-block模式的socket。

水平触发（LT）：读缓冲区非空就会一直触发，写缓冲区只要不满就会一直触发写事件。
边缘触发（ET）：读缓冲区空转非空（有新消息）的时候触发一次，写缓冲区从满到非满的时候（空出来可以写了）触发一次。



水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？

剩下的300 等新数据到来的时候 会再触发 可以进行读取



## 不使用高级工具，只使用Linux自带的工具，你会如何debug?

1. 



总结：

如果我们用水平触发不用担心数据有没有读完因为下次epoll返回时，没有读完的socket依然会被返回，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此**长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满**，所以**在水平触发模式下我们一般不关注可写事件**，而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次或者多次。

所以有时候我们也会用到边缘触发，但是这种模式下在读数据的时候一定要注意，因为如果一次可读事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。





个人看法：

对于读事件：如果业务可以保证每次都可以读完，那就可以使用ET，否则使用LT

对于写事件：如果一次性可以写完那就可以使用LT，写完删除写事件就可以了.

但是如果写的数据很大也不在意延迟，那么就可以使用ET，因为ET可以保证在发送缓冲区变为空时才再次通知（而LT则是发送缓冲区空了就可以通知就绪，这样就每次触发就只能写一点点数据，内核切换开销以及内存拷贝开销过大）

操作系统内存管理





6.8大小的水果袋，给定m个水果，要求正好装满袋子，返回6、8大小袋子的数量，如果不能正好装满都返回0。用的DP做的







java如何修改字节码



场景题：怎么保证订单只能退款一次(幂等性？)

## 1、token机制

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

![img](https://pic2.zhimg.com/v2-a813e4f94b89049877fe513264e0eb5d_b.jpg)

具体流程步骤：

1.客户端会先发送一个请求去获取 token，服务端会生成一个**全局唯一的 ID 作为 token** 保存在 redis 中，同时把这个 ID 返回给客户端

2.客户端第二次调用业务请求的时候必须携带这个 token

3.服务端会校验这个token,如果校验成功，则执行业务，并删除 redis 中的 token

4.如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端



注意：

1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成 （涉及分布式ID  都是基于雪花算法的 是一个64位的long 类型 第一个bit是标识部分，时间戳41bit 工作机器id 10bit 可以前5位作为数据中心机房标记 后5位作为单机房机器标识 序列号12bit ）
   1. uid-generator的 workid 可以自定义 默认是 往数据库插入一条数据 而返回的自增id就是该机器的workId，而数据由host port组成
   2. 美团的Leaf支持号段模式 也支持雪花算法 snowflake也是在workid上做文章 是有zk的顺序ID来生成的

## **2、基于 mysql 实现**

![img](https://pic1.zhimg.com/v2-dc3df46efad1657a9785aebbc2069b5c_b.jpg)



具体流程步骤：

1. 建立一张去重表，其中**某个字段需要建立唯一索引**。
2. 客户端去请求服务端，服务端会将这次请求信息插入一张去重表中
3. 因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑
4. 如果插入失败，则代表已经执行过当前请求，直接返回



例如 退款场景下 订单id



## **3、基于 redis 实现**

这种实现方式是基于 SETNX 命令实现的

SETNX [key value](https://www.zhihu.com/search?q=key+value&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"345512692"})：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。

该命令在设置成功时返回 1，设置失败时返回 0。

示意图如下：

![img](https://pic2.zhimg.com/v2-6ae389fa7bcb099a8f8a6eaf89f5f46d_b.jpg)

具体流程步骤：

1. 客户端先请求服务端，会拿到一个能代表这次请求业务的**唯一字段**
2. 将该字段以 SETNX 的方式存入 redis 中，并根据业务设置相应的超时时间
3. 如果**设置成功，证明这是第一次请求，则执行后续的业务逻辑**
4. 如果设置失败，则代表已经执行过当前请求，直接返回

例如 退款场景 订单id是唯一字段的话 就可以在setnx中 把 订单id作为key





什么情况下会出现oom？



# 堆溢出

这种场景最为常见，报错信息：`java.lang.OutOfMemoryError: Java heap space`

1.大对象分配

2.可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。



解决方法：

1.检查是否存在大对象的分配，最有可能的是大数组分配 还可以看看大文件读取代码

2.通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题

3.如果没有找到明显的内存泄露，使用 -Xmx 加大堆内存

4.还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性



堆内存溢出如何排查？

Java的堆用于存储对象实例，只要不断地创建对象，并且保证GC root 到对象之间有可达路径，就无法被收集器回收。
在java工程的目录下新建一个类，这里命名为MemoryController，代码如下：

```java
@RestController
public class MemoryController {
    private List<TestEntity>  heapList = new ArrayList<>();
    /**
     * -Xmx32M -Xms32M
     * */
    @GetMapping("/heap")
    public String heap() {
        long i=1l;
        while(true) {
            heapList.add(new TestEntity(i++, UUID.randomUUID().toString()));
        }
    }
}
```

内存泄漏

《深入理解Java虚拟机》书中给出这种情况的解决思路：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529132021280.png)

（1)如果是内存泄漏，查GCRoot引用链，打印出引用链信息，就基本可以定位泄露代码的为位置。

(2）如果不存在泄露，也就是内存中的对象确实都必须存活，就检查虚拟机的堆参数。看看-Xmx和-Xms在机器物理内存的基础上可否再调大。







# 永久代/元空间溢出

```java
java.lang.OutOfMemoryError: PermGen spacejava.lang.OutOfMemoryError: Metaspace
```



原因：

永久代是hotspot虚拟机对方法区的具体实现，存放了被JVM加载的类信息.常量/静态变量/JIT编译后的代码等

jdk8后 元空间代替了永久代，元空间使用的是本地内存，还有其他细节变化

字符串常量由永久代转移到堆中和永久代相关的JVM参数已移除

可能的原因有如下几种：

1. 在Java7之前，频繁的错误使用String.intern()方法
2. 运行期间生成了大量的代理类，导致方法区被撑破
3. 应用长时间运行

解决方法
因为该OOM原因比较简单，解决方法有如下几种：
1、检查是否永久代空间或者元空间设置的过小
2、检查代码中是否存在大量的反射操作
3、dump之后通过mat检查是否存在大量由于反射生成的代理类
4、放大招，重启JVM

GC overhead limit exceeded
这个异常比较的罕见，报错信息：java.lang.OutOfMemoryError：GC overhead limit exceeded
原因
这个是JDK6新加的错误类型，一般都是堆太小导致的。Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。
解决方法
1、检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。
2、添加参数 -XX:-UseGCOverheadLimit 禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space。
3、dump内存，检查是否存在内存泄露，如果没有，加大内存。

方法栈溢出
报错信息：java.lang.OutOfMemoryError : unable to create new native Thread

原因
出现这种异常，基本上都是创建的了大量的线程导致的，以前碰到过一次，通过jstack出来一共8000多个线程。
解决方法

1、通过 -Xss 降低的每个线程栈大小的容量
2、线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：
/proc/sys/kernel/pid_max
/proc/sys/kernel/thread-maxmaxuserprocess（ulimit -u）
/proc/sys/vm/maxmapcount

非常规溢出
下面这些OOM异常，可能大部分的同学都没有碰到过，但还是需要了解一下
分配超大数组
报错信息 ：java.lang.OutOfMemoryError: Requested array size exceeds VM limit

这种情况一般是由于不合理的数组分配请求导致的，在为数组分配内存之前，JVM 会执行一项检查。要分配的数组在该平台是否可以寻址(addressable)，如果不能寻址(addressable)就会抛出这个错误。
解决方法就是检查你的代码中是否有创建超大数组的地方。

swap溢出
报错信息 ：java.lang.OutOfMemoryError: Out of swap space
这种情况一般是操作系统导致的，可能的原因有：
1、swap 分区大小分配不足；
2、其他进程消耗了所有的内存。
解决方案：
1、其它服务进程可以选择性的拆分出去 2、加大swap分区大小，或者加大机器内存大小

本地方法溢出
报错信息 ：java.lang.OutOfMemoryError: stack_trace_with_native_method
本地方法在运行时出现了内存分配失败，和之前的方法栈溢出不同，方法栈溢出发生在 JVM 代码层面，而本地方法溢出发生在JNI代码或本地方法处。
这个异常出现的概率极低，只能通过操作系统本地工具进行诊断，难度有点大，还是放弃为妙。





具体场景：



1.程序中有死循环 不断创建新的对象

2.内存泄漏

当出现了内存溢出，你怎么排错。







2msl是如何测算出来的

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置，

初始值，但ttl并不是存在的具体时间，而是一个IP数据报可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。TTL与MSL是有关系的但不是简单的相等关系，MSL要大于TTL。

 









## 网关如何保证可用性：

1.集群部署

2.负载均衡

3.健康检查

4.节点自动重启

5.熔断

6.服务降级

7.接口重试





rpc技术选型？为什么选择zk 为什么使用netty 为什么序列化使用 

grpc和dubbo





## 大数据算法题：代码实现



## 如何改善zookeeper的单点故障 以及单点并发性能问题

可以采用多主节点的方案 





# 源码角度深入理解JDK代理与CGLIB代理



## JDK与CGLIB对比

### JDK

**特点：**

- 目标类必须实现接口
- 使用反射生成代理对象

### CGLIB

CGLIB 代理执行过程：调用目标方法 —> 执行目标方法的回调： 拦截器 —> 找到目标方法对应的索引 —> 找到索引对应目标方法并执行

**特点：**

- 目标类不需要实现接口，但不能用 final 修饰
- CGLIB 调用目标方法采用的是索引（类似于方法调用）的方式，比反射调用效率高

早期版本的 JDK 代理效率远远小于 CGLIB，但随着 jdk 的不断迭代优化，但 Spring 的 CGLIB 却止步不前，可以得知，较新版本的（JDK7及以后）JDK 代理的整体效率要高于 CGLIB代理。但 CGLIB 调用目标方法的性能要优于JDK使用反射调用方法的性能。



### 使用场景

到这里相信各位小伙伴们已经基本掌握了JDK动态代理和CGlib动态代理的区别和实现

但是，如果是在面试过程中，除了要答出以上要点，你还要回答出它们的使用场景，这其实就是面试的加分项

那么，这两个动态代理的使用场景是什么呢？？？

答案：Spring AOP

以下是Spring AOP创建代理的方法

```java
@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {

   if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
      Class<?> targetClass = config.getTargetClass();
      if (targetClass == null) {
         throw new AopConfigException("TargetSource cannot determine target class: " +
               "Either an interface or a target is required for proxy creation.");
      }
      //如果
      if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
         return new JdkDynamicAopProxy(config);
      }
      return new ObjenesisCglibAopProxy(config);
   }
   else {
      return new JdkDynamicAopProxy(config);
   }
}

```



1、如果目标对象实现了接口，**默认情况下会采用JDK的动态代理**

2、如果目标对象实现了接口，也可以**强制使用CGLIB**3、如果目标对象**没有实现了接口，必须采用CGLIB库**，spring会自动在JDK动态代理和CGLIB之间转换

**如果需要强制使用CGLIB来实现AOP，需要配置**spring.aop.proxy-target-class=true或@EnableAspectJAutoProxy(proxyTargetClass= true


s



## 反射的原理：



我们以前面试验中反射生成实例的代码为入口。

首先回顾下虚拟机中类的生命周期：**加载，连接（验证，准备，解析），初始化，使用，卸载**。在加载的过程 中，**虚拟机会把类的字节码转换成运行时数据结构，并保存在方法区**，在内存中会**生成一个代表这个类数据结构**的 java.lang.**Class 对象**，后续访问这个类的数据结构就可以通过这个 Class 对象来访问。

```java
public InnerClass newInstanceByReflection() {
    // 获取虚拟机中 InnerClass 类的 Class 对象
    Class clazz = InnerClass.class;
    try {
        return (InnerClass) clazz.getDeclaredConstructor().newInstance();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
    return null;
}

```



代码中 `clazz.getDeclaredConstructor()` 用于获取类中定义的构造方法，由于我们没有显式定义构造方法，所以会返回编译器为我们自己生成的默认无参构造方法。

下面我们看下 `getDeclaredConstructor`是如何返回构造方法的。以下均以 jdk 1.8代码为源码。

```java
@CallerSensitive
public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
    throws NoSuchMethodException, SecurityException {
    // 权限检查
    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
    return getConstructor0(parameterTypes, Member.DECLARED);
}

```

`getDeclaredConstructor` 方法首先做了权限检查，然后直接调用 `getConstructor0` 方法。



```java
private Constructor<T> getConstructor0(Class<?>[] parameterTypes,
                                    int which) throws NoSuchMethodException
{
    // privateGetDeclaredConstructors 方法是获取所有的构造方法数组
    Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
    // 遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的构造方法后就会拷贝一份作为返回值
    for (Constructor<T> constructor : constructors) {
        if (arrayContentsEq(parameterTypes,
                            constructor.getParameterTypes())) {
            // 拷贝构造方法
            return getReflectionFactory().copyConstructor(constructor);
        }
    }
    // 没有找到的话，就抛出异常 
    throw new NoSuchMethodException(getName() + ".<init>" + argumentTypesToString(parameterTypes));
}

```

`getConstructor0` 方法主要做了两件事：

1.获取所有的构造方法数组

2.遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的改造方法后就会拷贝一份作为返回值

遍历匹配没啥好说的，我们重点看下第一件事，**怎么获取的所有构造方法数组**，也就是这个方法 `privateGetDeclaredConstructors`。

```java
private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) {
    checkInitted();
    Constructor<T>[] res;
    // 获取缓存的 ReflectionData 数据
    ReflectionData<T> rd = reflectionData();
    // 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空
    if (rd != null) {
        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
        if (res != null) return res;
    }
    // 如果没有缓存，或者缓存中构造方法数组为空
    // No cached value available; request value from VM
    // 对接口类型的字节码特殊处理
    if (isInterface()) {
        @SuppressWarnings("unchecked")
        // 如果是接口类型，那么生成一个长度为0的构造方法数组
        Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor<?>[0];
        res = temporaryRes;
    } else {
        // 如果不是接口类型，就调用 getDeclaredConstructors0 获取构造方法数组
        res = getDeclaredConstructors0(publicOnly);
    }
    // 获取到构造方法数组后，再赋值给缓存 ReflectionData 中的对应属性
    if (rd != null) {
        if (publicOnly) {
            rd.publicConstructors = res;
        } else {
            rd.declaredConstructors = res;
        }
    }
    return res;
}

```



1. 获取缓存的 ReflectionData 数据
2. 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空
3. 如果没有缓存，或者缓存中构造方法数组为空



上述代码中我已经对关键代码进行了注释，在讲解整个流程之前，我们看到了一个陌生的类型 `ReflectionData`。它对应的数据结构是：

```java
private static class ReflectionData<T> {
    volatile Field[] declaredFields;
    volatile Field[] publicFields;
    volatile Method[] declaredMethods;
    volatile Method[] publicMethods;
    volatile Constructor<T>[] declaredConstructors;
    volatile Constructor<T>[] publicConstructors;
    // Intermediate results for getFields and getMethods
    volatile Field[] declaredPublicFields;
    volatile Method[] declaredPublicMethods;
    volatile Class<?>[] interfaces;

    // Value of classRedefinedCount when we created this ReflectionData instance
    final int redefinedCount;

    ReflectionData(int redefinedCount) {
        this.redefinedCount = redefinedCount;
    }
}

```

`ReflectionData`这个类就是用来保存从虚拟机中获取到的一些数据。同时我们看到所有的反射属性都用上了volatile关键字修饰

获取缓存的 `ReflectionData` 数据是通过调用`reflectionData()`方法获取的。

```java
// 定义在 Class 类中的反射缓存对象
private volatile transient SoftReference<ReflectionData<T>> reflectionData;

private ReflectionData<T> reflectionData() {
    SoftReference<ReflectionData<T>> reflectionData = this.reflectionData;
    int classRedefinedCount = this.classRedefinedCount;
    ReflectionData<T> rd;
    if (useCaches &&
        reflectionData != null &&
        (rd = reflectionData.get()) != null &&
        rd.redefinedCount == classRedefinedCount) {
        return rd;
    }
    // else no SoftReference or cleared SoftReference or stale ReflectionData
    // -> create and replace new instance
    return newReflectionData(reflectionData, classRedefinedCount);
}

```

我们可以看到 `reflectionData`实际上是一个软引用，软引用会在内存不足的情况下被虚拟机回收，所以`reflectionData()`方法在开始的地方，先判断了是否可以使用缓存以及缓存是否失效，如果失效了，就会调用 `newReflectionData`方法生成一个新的 `ReflectionData` 实例。


接下来看看 `newReflectionData` 方法。

```java
private ReflectionData<T> newReflectionData(SoftReference<ReflectionData<T>> oldReflectionData,
                                                int classRedefinedCount) {
    // 如果不允许使用缓存，直接返回 null
    if (!useCaches) return null;
	
    while (true) {
        ReflectionData<T> rd = new ReflectionData<>(classRedefinedCount);
        // try to CAS it...
        if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<>(rd))) {
            return rd;
        }
        // else retry
        oldReflectionData = this.reflectionData;
        classRedefinedCount = this.classRedefinedCount;
        if (oldReflectionData != null &&
            (rd = oldReflectionData.get()) != null &&
            rd.redefinedCount == classRedefinedCount) {
            return rd;
        }
    }
}
```



newRelectionData中使用volatile+死循环+CAS机制 保证线程安全。注意这里的死循环每执行一次都会构造一个新的 `ReflectionData` 实例。



你可能会有疑问，`Class` 中 `reflectionData`属性什么时候被赋值的，其实是封装在`Atomic.casReflectionData`这个方法里了，他会检测当前`Class`对象中的`reflectionData`是否与`oldReflectionData`相等，如果相等，就会把`new SoftReference<>(rd)`赋值给 `reflectionData`。

到现在为止，关于 `ReflectionData`的背景知识都介绍完了。我们再回到 `privateGetDeclaredConstructors`中看看获取构造方法的流程。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/20/170f7df304157365~tplv-t2oaga2asx-watermark.awebp)









## 反射带来的问题



到现在为止，我们已经把反射生成实例的所有流程都搞清楚了。回到文章开头的问题，我们现在反思下，反射性能低么？为什么？

1. 反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。
2. 反射调用方法时会从方法数组中遍历查找，并且会检查可见性等操作会耗时。例如获取构造器 需要遍历构造器数组 然后进行匹配 
3. 反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。
4. 反射一般会涉及自动装箱/拆箱和类型转换，都会带来一定的资源开销。

**本文的结论如下：**

1. 不要在性能敏感的应用中，频繁调用反射。
2. 如果反射执行的次数小于1000这个数量级，反射的耗时实际上与正常调用无太大差异。
3. 反射对内存占用还有一定影响的，在内存敏感的场景下，谨慎使用反射。





怎么在linux中打开一个1G的文件

如何保证线程安全

思维题:一根金条，需要付给工人，工人工作七天，需要每天给他一段1/7的金条，如何保证切两刀就完成任务。



智力题 如何在1-21个无序数字中找到缺失的数字



7.分布式事务的处理方法
8.可靠消息+最终一致性的解决方案





## 水平分表，大量数据如何进行分表，比如说淘宝一天有1亿个订单号？



如果有很多按照 user_id的查询语句，那么可以按照user_id来进行分表









## 数据库建表场景题







## 设计一个评论系统 

1.支持以页面ID（page_ID）为维度进行评论

2.要求增删改 按页面查询列表 按用户查询

3.给出接口列表入参 表结构



### 评论系统数据库设计及实现

需求分析：

![img](http://ww1.sinaimg.cn/mw690/0079MVdAly1g22kaulq08j30j80k8dms.jpg)

这种评论层层嵌套，每个评论下面还挂着若干个对评论的回复。

这种类似于树状结构，用户看起来一目了然，也是一种非常主流的评论系统。

### 数据库设计

在以评论为主的树形结构中，数据库的设计非常灵活，可以是单表设计，每个评论都有一个parent_id指向父评论。还可以分开为两张表，评论一张表，对评论的回复是另一张表。

这里我使用的是单表设计。

数据表设计如下。由于我开发的是一个新闻系统，所以我就直接以项目举例。

| 表字段    | 字段说明                                            |
| --------- | --------------------------------------------------- |
| commentId | 评论的id，自增值，每个评论都对应一个唯一的commentId |
| newsId    | 评论所对应的新闻的id                                |
| content   | 评论的内容                                          |
| userId    | 发出该评论用户的id                                  |
| parentId  | 指向父评论的id,如果不是对评论的回复,那么该值为null  |
| date      | 评论产生日期                                        |
| pageId    | 页面id                                              |



```sql
create table if not exists comments
(
  comment_id bigint auto_increment primary key,
  news_id bigint not null,
  parent_id  bigint,
  content text not null,
  user_id bigint not null,
  date timestamp default current_timestamp().
  page_id,int not null
  index index_user_id(user_id),
  index index_page_id(page_id),
  foreign key (parent_id) references comments (commentId),
  foreign key (user_id) references users (userId),
  foreign key (news_id) references news (newsId)
)charset = utf8mb4;
```



支持以页面ID（page_ID）为维度进行评论

接口入参

comment_id,news_id,content,user_id,page_id

sql语句

```sql
insert into comments(comment_id,news_id,content,user_id,page_id) value(1,2,'今天要涨',12,1);
```





按页面查询列表

接口入参：pageId 

```sql
SELECT a.commentId,a.newsId,a.parentId,a.newsId,b.nickname,b.avatar,a.content,a.date   FROM comments AS a,users AS b WHERE a.page_id=#{pageId} AND a.userId=b.userId
```



按用户查询：

接口入参：userId 

```sql
SELECT a.commentId,a.newsId,a.parentId,a.newsId,b.nickname,b.avatar,a.content,a.date   FROM comments AS a,users AS b WHERE a.user_id=#{userId} AND a.userId=b.userId
```





